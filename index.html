<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>Апартаменты в аренду Севастополь посуточно вид моря | Большая Терраса GrandTerraceApt | Квартира Севастополь аренда посуточно</title>
  <style>
    /* Все предыдущие стили остаются без изменений */
    /* ... */
    
    /* Добавим индикатор загрузки для отладки */
    .debug-indicator {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 12px;
      z-index: 9999;
      display: none;
    }
  </style>
</head>
<body>
  <!-- Индикатор отладки -->
  <div class="debug-indicator" id="debugIndicator"></div>

  <!-- Весь HTML остается без изменений -->
  <!-- ... -->

  <!-- Подключение API Яндекс.Карт -->
  <script src="https://api-maps.yandex.ru/2.1/?apikey=ВАШ_API_КЛЮЧ&lang=ru_RU" type="text/javascript"></script>
  
  <script>
    // Глобальные переменные для управления
    let myMap = null;
    let orientationChangeInProgress = false;
    let currentOrientation = getOrientation();
    let resizeTimeout = null;
    let orientationTimeout = null;
    let recoveryAttempts = 0;
    const MAX_RECOVERY_ATTEMPTS = 3;

    // Функции для отладки
    function showDebug(message) {
      const indicator = document.getElementById('debugIndicator');
      if (indicator) {
        indicator.textContent = message;
        indicator.style.display = 'block';
        setTimeout(() => {
          indicator.style.display = 'none';
        }, 3000);
      }
      console.log('DEBUG:', message);
    }

    // Универсальная функция получения ориентации
    function getOrientation() {
      return window.orientation !== undefined ? window.orientation : 
             (window.screen.orientation ? window.screen.orientation.angle : 0);
    }

    // Функция для сохранения данных формы
    function saveFormData() {
      const form = document.getElementById('bookingForm');
      if (!form) return;
      
      const formData = {
        name: document.getElementById('name').value,
        email: document.getElementById('email').value,
        phone: document.getElementById('phone').value,
        checkin: document.getElementById('checkin').value,
        checkout: document.getElementById('checkout').value,
        guests: document.getElementById('guests').value,
        message: document.getElementById('message').value
      };
      
      sessionStorage.setItem('bookingFormData', JSON.stringify(formData));
    }

    // Функция для восстановления данных формы
    function restoreFormData() {
      const savedData = sessionStorage.getItem('bookingFormData');
      if (!savedData) return;
      
      try {
        const formData = JSON.parse(savedData);
        
        if (formData.name) document.getElementById('name').value = formData.name;
        if (formData.email) document.getElementById('email').value = formData.email;
        if (formData.phone) document.getElementById('phone').value = formData.phone;
        if (formData.checkin) document.getElementById('checkin').value = formData.checkin;
        if (formData.checkout) document.getElementById('checkout').value = formData.checkout;
        if (formData.guests) document.getElementById('guests').value = formData.guests;
        if (formData.message) document.getElementById('message').value = formData.message;
      } catch (e) {
        console.error('Ошибка восстановления данных формы:', e);
      }
    }

    // Функция для очистки сохраненных данных формы
    function clearFormData() {
      sessionStorage.removeItem('bookingFormData');
    }

    // Улучшенная функция для полного уничтожения и пересоздания карты
    function recreateMap() {
      if (!myMap) {
        showDebug('Карта не существует, инициализируем заново');
        initMap();
        return;
      }
      
      try {
        showDebug('Пересоздание карты...');
        
        // Сохраняем текущее состояние карты
        const center = myMap.getCenter();
        const zoom = myMap.getZoom();
        
        // Уничтожаем старую карту
        myMap.destroy();
        myMap = null;
        
        // Полностью очищаем контейнер карты
        const mapContainer = document.getElementById('map');
        mapContainer.innerHTML = '';
        
        // Создаем новый контейнер для карты
        const newMapDiv = document.createElement('div');
        newMapDiv.id = 'map';
        newMapDiv.style.width = '100%';
        newMapDiv.style.height = '100%';
        mapContainer.appendChild(newMapDiv);
        
        // Даем время на полное уничтожение
        setTimeout(() => {
          initMap(center, zoom);
          recoveryAttempts = 0; // Сбрасываем счетчик попыток
        }, 400);
      } catch (error) {
        console.error('Ошибка при пересоздании карты:', error);
        showDebug('Ошибка пересоздания карты');
        // Если произошла ошибка, пытаемся инициализировать заново
        setTimeout(() => {
          initMap();
        }, 600);
      }
    }

    // Улучшенная функция для принудительного обновления формы
    function refreshFormLayout() {
      const form = document.getElementById('bookingForm');
      if (!form) return;
      
      // Сохраняем данные перед обновлением
      saveFormData();
      
      // Принудительно вызываем перерисовку формы через несколько методов
      form.style.transform = 'scale(0.999)';
      void form.offsetHeight; // Принудительный reflow
      form.style.transform = 'scale(1)';
      
      // Альтернативный метод перерисовки
      setTimeout(() => {
        form.style.display = 'none';
        void form.offsetHeight;
        form.style.display = 'block';
        
        // Восстанавливаем данные после обновления
        setTimeout(restoreFormData, 50);
      }, 100);
    }

    // Основная функция восстановления layout
    function recoverLayout() {
      if (orientationChangeInProgress) {
        showDebug('Восстановление уже выполняется');
        return;
      }
      
      orientationChangeInProgress = true;
      recoveryAttempts++;
      
      showDebug(`Попытка восстановления ${recoveryAttempts}/${MAX_RECOVERY_ATTEMPTS}`);
      
      // Сохраняем данные формы перед любыми изменениями
      saveFormData();
      
      // Сбрасываем viewport (важно!)
      const viewport = document.querySelector('meta[name="viewport"]');
      if (viewport) {
        viewport.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover';
      }
      
      // Принудительно вызываем несколько событий resize
      window.dispatchEvent(new Event('resize'));
      
      // Многоуровневое восстановление с разными задержками
      const recoverySteps = [
        { delay: 100, action: 'initial' },
        { delay: 300, action: 'form' },
        { delay: 500, action: 'map' },
        { delay: 800, action: 'final' }
      ];
      
      recoverySteps.forEach(step => {
        setTimeout(() => {
          switch (step.action) {
            case 'initial':
              // Первоначальные корректировки
              window.dispatchEvent(new Event('resize'));
              break;
            case 'form':
              // Обновляем форму
              refreshFormLayout();
              break;
            case 'map':
              // Работа с картой
              if (myMap) {
                try {
                  myMap.container.fitToViewport();
                  // Дополнительные попытки для карты
                  setTimeout(() => {
                    if (myMap) myMap.container.fitToViewport();
                  }, 200);
                } catch (e) {
                  showDebug('Ошибка обновления карты');
                }
              }
              break;
            case 'final':
              // Финальные корректировки
              window.dispatchEvent(new Event('resize'));
              
              // Проверяем, нужно ли пересоздать карту
              if (myMap && recoveryAttempts >= MAX_RECOVERY_ATTEMPTS) {
                showDebug('Максимальное количество попыток, пересоздаем карту');
                recreateMap();
              }
              
              orientationChangeInProgress = false;
              showDebug('Восстановление завершено');
              break;
          }
        }, step.delay);
      });
    }

    // Улучшенный обработчик изменения ориентации
    function handleOrientationChange() {
      const newOrientation = getOrientation();
      
      // Проверяем, действительно ли изменилась ориентация
      if (newOrientation === currentOrientation && !orientationChangeInProgress) {
        return;
      }
      
      showDebug(`Изменение ориентации: ${currentOrientation} -> ${newOrientation}`);
      currentOrientation = newOrientation;
      
      // Сбрасываем предыдущие таймауты
      clearTimeout(orientationTimeout);
      
      // Запускаем восстановление с задержкой
      orientationTimeout = setTimeout(() => {
        recoverLayout();
      }, 150);
    }

    // Улучшенный обработчик изменения размера
    function handleResize() {
      clearTimeout(resizeTimeout);
      
      // Проверяем, действительно ли изменился размер
      const currentWidth = window.innerWidth;
      const currentHeight = window.innerHeight;
      
      resizeTimeout = setTimeout(() => {
        const newWidth = window.innerWidth;
        const newHeight = window.innerHeight;
        
        // Если размер значительно изменился, запускаем восстановление
        if (Math.abs(newWidth - currentWidth) > 50 || Math.abs(newHeight - currentHeight) > 50) {
          showDebug('Значительное изменение размера');
          if (!orientationChangeInProgress) {
            recoverLayout();
          }
        }
      }, 250);
    }

    // Множественные обработчики для надежности
    function setupEventListeners() {
      // Основные обработчики
      window.addEventListener('orientationchange', handleOrientationChange);
      window.addEventListener('resize', handleResize);
      
      // Дополнительные обработчики для разных браузеров
      window.addEventListener('load', recoverLayout);
      
      // Обработчик для fullscreen changes (может влиять на layout)
      document.addEventListener('fullscreenchange', recoverLayout);
      document.addEventListener('webkitfullscreenchange', recoverLayout);
      
      // Обработчик видимости страницы (на случай, когда вкладка становится активной)
      document.addEventListener('visibilitychange', () => {
        if (!document.hidden) {
          setTimeout(recoverLayout, 500);
        }
      });
      
      // Периодическая проверка (fallback)
      setInterval(() => {
        if (orientationChangeInProgress) return;
        
        // Проверяем, не искажен ли layout
        const mapContainer = document.getElementById('map');
        if (mapContainer && myMap) {
          const containerRect = mapContainer.getBoundingClientRect();
          if (containerRect.width < 100 || containerRect.height < 100) {
            showDebug('Обнаружена проблема с layout, восстанавливаем...');
            recoverLayout();
          }
        }
      }, 30000); // Проверка каждые 30 секунд
    }

    // Функция инициализации карты
    function initMap(center = null, zoom = null) {
      if (typeof ymaps === 'undefined') {
        console.error('Yandex Maps API не загрузился');
        document.getElementById('map').innerHTML = '<div class="map-placeholder">Карта временно недоступна</div>';
        return;
      }
      
      if (myMap) return;
      
      ymaps.ready(function() {
        const apartmentCoords = [44.616622961342124, 33.517859032692016];
        
        try {
          myMap = new ymaps.Map('map', {
            center: center || apartmentCoords,
            zoom: zoom || 16,
            controls: ['zoomControl', 'fullscreenControl']
          });
          
          const myPlacemark = new ymaps.Placemark(apartmentCoords, {
            hintContent: 'Апартаменты "Большая Терраса"',
            balloonContent: 'Апартаменты "Большая Терраса"<br>набережная Адмирала Перелешина, 3<br>Севастополь'
          }, {
            preset: 'islands#redIcon'
          });
          
          myMap.geoObjects.add(myPlacemark);
          myPlacemark.balloon.open();
          myMap.behaviors.disable('scrollZoom');
          
          // Множественные попытки корректного отображения
          [100, 300, 600, 1000].forEach(delay => {
            setTimeout(() => {
              if (myMap) {
                try {
                  myMap.container.fitToViewport();
                } catch (e) {
                  console.error('Ошибка при fitToViewport:', e);
                }
              }
            }, delay);
          });
          
        } catch (error) {
          console.error('Ошибка при создании карты:', error);
          document.getElementById('map').innerHTML = '<div class="map-placeholder">Ошибка загрузки карты</div>';
        }
      });
    }

    // Инициализация при загрузке
    document.addEventListener('DOMContentLoaded', function() {
      showDebug('Страница загружается');
      
      // Инициализация карты
      initMap();
      
      // Восстановление данных формы
      restoreFormData();
      
      // Настройка обработчиков событий
      setupEventListeners();
      
      // Добавляем обработчики для сохранения данных формы
      const form = document.getElementById('bookingForm');
      if (form) {
        form.addEventListener('input', saveFormData);
        form.addEventListener('change', saveFormData);
      }

      // Инициализация lightbox (остальной код без изменений)
      const lightbox = document.getElementById('lightbox');
      const lightboxSlides = document.getElementById('lightboxSlides');
      const lightboxClose = document.getElementById('lightboxClose');
      const prevButton = document.getElementById('prevButton');
      const nextButton = document.getElementById('nextButton');
      const lightboxCounter = document.getElementById('lightboxCounter');
      const zoomInButton = document.getElementById('zoomIn');
      const zoomOutButton = document.getElementById('zoomOut');
      const resetZoomButton = document.getElementById('resetZoom');
      const galleryItems = document.querySelectorAll('.gallery-item');
      
      let currentImageIndex = 0;
      let startX = 0;
      let currentX = 0;
      let isDragging = false;
      let currentScale = 1;
      let currentTranslate = { x: 0, y: 0 };
      let initialTouchesDistance = 0;
      
      // Создаем слайды для lightbox
      function createSlides() {
        lightboxSlides.innerHTML = '';
        galleryItems.forEach((item, index) => {
          const slide = document.createElement('div');
          slide.className = 'lightbox-slide';
          if (index === currentImageIndex) slide.classList.add('active');
          
          const imageContainer = document.createElement('div');
          imageContainer.className = 'lightbox-image-container';
          
          const img = document.createElement('img');
          img.src = item.querySelector('img').src;
          img.alt = item.querySelector('img').alt;
          img.dataset.initialTransform = 'scale(1) translate(0, 0)';
          
          const caption = document.createElement('div');
          caption.className = 'lightbox-caption';
          caption.textContent = item.querySelector('.gallery-caption').textContent;
          
          imageContainer.appendChild(img);
          slide.appendChild(imageContainer);
          slide.appendChild(caption);
          lightboxSlides.appendChild(slide);
        });
        
        updateCounter();
        resetImageTransform();
      }
      
      // Обновление счетчика
      function updateCounter() {
        lightboxCounter.textContent = `${currentImageIndex + 1} / ${galleryItems.length}`;
      }
      
      // Сброс трансформации изображения
      function resetImageTransform() {
        currentScale = 1;
        currentTranslate = { x: 0, y: 0 };
        const activeImage = document.querySelector('.lightbox-slide.active img');
        if (activeImage) {
          activeImage.style.transform = `scale(1) translate(0, 0)`;
        }
      }
      
      // Показать определенный слайд
      function showSlide(index) {
        const slides = document.querySelectorAll('.lightbox-slide');
        slides.forEach(slide => slide.classList.remove('active'));
        
        currentImageIndex = index;
        if (currentImageIndex < 0) {
          currentImageIndex = galleryItems.length - 1;
        } else if (currentImageIndex >= galleryItems.length) {
          currentImageIndex = 0;
        }
        
        slides[currentImageIndex].classList.add('active');
        resetImageTransform();
        updateCounter();
      }
      
      // Открытие lightbox
      galleryItems.forEach((item, index) => {
        item.addEventListener('click', () => {
          currentImageIndex = index;
          createSlides();
          lightbox.classList.add('open');
          document.body.style.overflow = 'hidden';
        });
      });
      
      // Закрытие lightbox
      lightboxClose.addEventListener('click', closeLightbox);
      lightbox.addEventListener('click', (e) => {
        if (e.target === lightbox) closeLightbox();
      });
      
      // Навигация
      prevButton.addEventListener('click', (e) => {
        e.stopPropagation();
        showSlide(currentImageIndex - 1);
      });
      
      nextButton.addEventListener('click', (e) => {
        e.stopPropagation();
        showSlide(currentImageIndex + 1);
      });
      
      // Управление масштабированием
      zoomInButton.addEventListener('click', (e) => {
        e.stopPropagation();
        zoomImage(1.2);
      });
      
      zoomOutButton.addEventListener('click', (e) => {
        e.stopPropagation();
        zoomImage(0.8);
      });
      
      resetZoomButton.addEventListener('click', (e) => {
        e.stopPropagation();
        resetImageTransform();
      });
      
      function zoomImage(factor) {
        const activeImage = document.querySelector('.lightbox-slide.active img');
        if (activeImage) {
          currentScale *= factor;
          // Ограничиваем масштаб
          currentScale = Math.max(0.5, Math.min(currentScale, 5));
          activeImage.style.transform = `scale(${currentScale}) translate(${currentTranslate.x}px, ${currentTranslate.y}px)`;
        }
      }
      
      // Навигация с клавиатуры
      document.addEventListener('keydown', (e) => {
        if (!lightbox.classList.contains('open')) return;
        
        if (e.key === 'Escape') closeLightbox();
        if (e.key === 'ArrowLeft') showSlide(currentImageIndex - 1);
        if (e.key === 'ArrowRight') showSlide(currentImageIndex + 1);
      });
      
      // Закрытие lightbox
      function closeLightbox() {
        lightbox.classList.remove('open');
        document.body.style.overflow = '';
      }
      
      // Обработка свайпов на мобильных устройствах
      lightbox.addEventListener('touchstart', handleTouchStart, false);
      lightbox.addEventListener('touchmove', handleTouchMove, false);
      lightbox.addEventListener('touchend', handleTouchEnd, false);
      
      function handleTouchStart(e) {
        if (e.touches.length === 1) {
          startX = e.touches[0].clientX;
          isDragging = true;
        } else if (e.touches.length === 2) {
          // Масштабирование двумя пальцами
          e.preventDefault();
          initialTouchesDistance = Math.hypot(
            e.touches[0].clientX - e.touches[1].clientX,
            e.touches[0].clientY - e.touches[1].clientY
          );
          isDragging = false;
        }
      }
      
      function handleTouchMove(e) {
        if (e.touches.length === 1 && isDragging) {
          currentX = e.touches[0].clientX;
          
          // Предотвращаем скролл страницы при горизонтальном свайпе
          if (Math.abs(currentX - startX) > 10) {
            e.preventDefault();
          }
        } else if (e.touches.length === 2) {
          // Масштабирование двумя пальцами
          e.preventDefault();
          const currentDistance = Math.hypot(
            e.touches[0].clientX - e.touches[1].clientX,
            e.touches[0].clientY - e.touches[1].clientY
          );
          
          if (initialTouchesDistance > 0) {
            const zoomFactor = currentDistance / initialTouchesDistance;
            const activeImage = document.querySelector('.lightbox-slide.active img');
            
            if (activeImage) {
              currentScale *= zoomFactor;
              // Ограничиваем масштаб
              currentScale = Math.max(0.5, Math.min(currentScale, 5));
              activeImage.style.transform = `scale(${currentScale}) translate(${currentTranslate.x}px, ${currentTranslate.y}px)`;
              
              initialTouchesDistance = currentDistance;
            }
          }
        }
      }
      
      function handleTouchEnd(e) {
        if (e.touches.length < 1) {
          isDragging = false;
          
          if (e.changedTouches.length === 1) {
            const diffX = currentX - startX;
            
            // Определяем направление свайпа
            if (Math.abs(diffX) > 50) { // Минимальная дистанция для свайпа
              if (diffX > 0) {
                // Свайп вправо - предыдущее изображение
                showSlide(currentImageIndex - 1);
              } else {
                // Свайп влево - следующее изображение
                showSlide(currentImageIndex + 1);
              }
            }
          }
        }
        
        if (e.touches.length < 2) {
          initialTouchesDistance = 0;
        }
      }

      // Обработка формы бронирования
      const bookingForm = document.getElementById('bookingForm');
      const formMessage = document.getElementById('formMessage');
      const submitBtn = document.getElementById('submitBtn');
      
      if (bookingForm) {
        // Установка минимальной даты (сегодня)
        const today = new Date().toISOString().split('T')[0];
        document.getElementById('checkin').setAttribute('min', today);
        document.getElementById('checkout').setAttribute('min', today);
        
        // Обновление минимальной даты для выезда при изменении даты заезда
        document.getElementById('checkin').addEventListener('change', function() {
          const checkinDate = this.value;
          document.getElementById('checkout').setAttribute('min', checkinDate);
          
          // Если дата выезда раньше даты заезда, устанавливаем дату выезда = дате заезда
          if (document.getElementById('checkout').value < checkinDate) {
            document.getElementById('checkout').value = checkinDate;
          }
          
          // Сохраняем изменения
          saveFormData();
        });
        
        // Отправка формы
        bookingForm.addEventListener('submit', function(e) {
          e.preventDefault();
          
          // Получаем данные формы
          const formData = {
            name: document.getElementById('name').value,
            email: document.getElementById('email').value,
            phone: document.getElementById('phone').value,
            checkin: document.getElementById('checkin').value,
            checkout: document.getElementById('checkout').value,
            guests: document.getElementById('guests').value,
            message: document.getElementById('message').value
          };
          
          // Валидация
          if (!formData.name || !formData.email || !formData.phone || !formData.checkin || !formData.checkout) {
            showMessage('Пожалуйста, заполните все обязательные поля', 'error');
            return;
          }
          
          // Блокируем кнопку отправки
          submitBtn.disabled = true;
          submitBtn.textContent = 'Отправка...';
          
          // Отправляем данные
          sendEmail(formData);
        });
      }
      
      // Функция показа сообщения
      function showMessage(text, type) {
        if (formMessage) {
          formMessage.textContent = text;
          formMessage.className = `form-message ${type} visible`;
          
          // Автоматическое скрытие через 5 секунд
          setTimeout(() => {
            formMessage.classList.remove('visible');
          }, 5000);
        }
      }
      
      // Функция отправки email через Formspree
      function sendEmail(formData) {
        // Формируем тело письма
        const subject = 'Новая заявка на бронирование';
        
        // Используем Formspree для отправки email
        fetch('https://formspree.io/f/xjvnzzwz', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            name: formData.name,
            email: formData.email,
            phone: formData.phone,
            checkin: formData.checkin,
            checkout: formData.checkout,
            guests: formData.guests,
            message: formData.message,
            _subject: subject,
            _replyto: formData.email
          })
        })
        .then(response => {
          if (response.ok) {
            showMessage('Заявка успешно отправлена! Мы свяжемся с вами в ближайшее время.', 'success');
            bookingForm.reset();
            // Очищаем сохраненные данные после успешной отправки
            clearFormData();
          } else {
            throw new Error('Ошибка отправки формы');
          }
        })
        .catch(error => {
          console.error('Ошибка:', error);
          showMessage('Произошла ошибка при отправке. Пожалуйста, попробуйте еще раз или свяжитесь с нами по телефону.', 'error');
        })
        .finally(() => {
          // Разблокируем кнопку отправки
          submitBtn.disabled = false;
          submitBtn.textContent = 'Отправить запрос';
        });
      }
      
      // Финальное восстановление после полной загрузки
      setTimeout(() => {
        recoverLayout();
      }, 1000);
    });
  </script>
</body>
</html>